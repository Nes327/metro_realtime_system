<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Metro Realtime â€” Route & Fare</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet core CSS/JS for map rendering -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    /*Design tokens*/
    :root{
      --bg:#f7f3e8;             /* app background*/
      --card:#ffffff;           /* card background*/
      --muted:#6b7280;          /* secondary text */
      --text:#111827;           /* primary text */
      --primary:#2563eb;        /* buttons / progress bar */
      --route:#7c3aed;          /* polyline color */
      --train-built:#0ea5a4;    /* built-in simulator train*/
      --train-gen:#ea580c;      /* generator train*/
      --chip:#6b7280;           /* station chip*/
      --chip-hi:#111827;        /* station chip highlight */
    }

    /* Basic layout*/
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
    h1{font-weight:800;letter-spacing:.4px;margin:0 0 6px}
    .sub{color:var(--muted);margin:0 0 16px;font-size:14px}
    .card{background:var(--card);border-radius:16px;box-shadow:0 6px 24px rgba(0,0,0,.08);padding:16px}

    /* Form controls */
    label{display:block;font-size:14px;color:#374151;margin:6px 0}
    select{
      width:100%;padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;
      font-size:15px;background:#fff;outline:none;
    }
    .grid2{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:720px){ .grid2{grid-template-columns:1fr 1fr;gap:16px} }

    /* Buttons row */
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    button{
      padding:10px 14px;border-radius:12px;border:0;background:var(--primary);color:#fff;
      cursor:pointer;font-weight:600;letter-spacing:.2px
    }
    button.secondary{background:#111;}
    button.warn{background:#9a3412;}
    button:disabled{opacity:.6;cursor:not-allowed}

    /* chips */
    .muted{color:var(--muted);font-size:13px}
    .ok{background:#f1f5f9;border:1px solid #e2e8f0;color:#0f172a;padding:10px;border-radius:10px}
    .error{background:#fee2e2;border:1px solid #fecaca;color:#991b1b;padding:10px;border-radius:10px}

    .path{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .chip{background:var(--chip);color:#fff;border-radius:999px;padding:6px 10px;font-size:13px;transition:.15s}
    .chip.active{background:var(--chip-hi)}
    .arrow{opacity:.35}

    /* Progress bar for overall trip progress */
    .bar{background:#e5e7eb;border-radius:8px;overflow:hidden;height:14px;margin:10px 0 6px}
    .bar > div{background:var(--primary);height:100%;width:0%}

    /* Map viewport */
    #map{height:420px;border-radius:12px;border:1px solid #e5e7eb}

    /* Station markers (Leaflet circleMarker) */
    .leaflet-interactive.station { stroke:#6b7280; fill:#6b7280; }

    /* Train marker as a small rounded badge with emoji (no text label) */
    .train-badge{
      display:inline-flex;align-items:center;justify-content:center;
      width:26px;height:20px;border-radius:999px;
      color:#fff;border:2px solid #fff;box-shadow:0 2px 6px rgba(0,0,0,.25);
      font-size:14px;line-height:1;
    }

    /* Legend */
    .legend{display:flex;gap:14px;align-items:center;margin:8px 0 0;font-size:13px;color:#374151;flex-wrap:wrap}
    .dot{display:inline-block;width:12px;height:12px;border-radius:50%}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Metro Realtime â€” Route Planner</h1>
    <p class="sub">Pick origin and destination, plan the route and fare.</p>

    <div class="card">
      <!-- Station pickers -->
      <div class="grid2">
        <div>
          <label for="fromSel">From (origin)</label>
          <select id="fromSel"></select>
        </div>
        <div>
          <label for="toSel">To (destination)</label>
          <select id="toSel"></select>
        </div>
      </div>

      <!-- Actions: plan, swap, start, stop sim -->
      <div class="row" style="margin:12px 0 6px">
        <button id="planBtn">Plan Route</button>
        <button id="swapBtn" class="secondary" title="Swap">â†” Swap</button>
        <button id="simBtn" style="background:var(--train-built)">Start Simulation</button>
        <button id="stopBtn" class="warn">Stop All Trains</button>
      </div>

      <!-- Result panel (route meta + chips) -->
      <div id="result" style="margin-top:8px"></div>

      <!-- Overall trip progress bar -->
      <div style="margin-top:10px">
        <div class="bar"><div id="totalBar" style="width:0%"></div></div>
        <div class="muted">Trip progress <span id="totalPct">0%</span></div>
      </div>

      <div class="legend">
        <span class="dot" style="background:var(--route)"></span> Route
        <span class="dot" style="background:#6b7280"></span> Station
        <span class="dot" style="background:var(--train-built)"></span> Simulation train
        <span class="dot" style="background:var(--train-gen)"></span> Generator train
      </div>

      <!-- Leaflet map container -->
      <div id="map" style="margin-top:10px"></div>
    </div>
  </div>

  <script>
    // DOM refs
    const $ = (sel)=>document.querySelector(sel);
    const fromSel = $('#fromSel');
    const toSel   = $('#toSel');
    const planBtn = $('#planBtn');
    const swapBtn = $('#swapBtn');
    const result  = $('#result');
    const simBtn  = $('#simBtn');
    const stopBtn = $('#stopBtn');
    const totalBar = $('#totalBar');
    const totalPct = $('#totalPct');

    // Map bootstrapping
    const map = L.map('map').setView([3.139, 101.6869], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      attribution:'&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Station data and marker cache
    const stationCoords = new Map();
    const stationMarkers = new Map();

    // Route polyline and live trains container
    let routeLine = null;
    const trains = new Map();

    // Build a Leaflet icon for trains
    const iconTrain = (source)=> {
      const bg = (source==='gen') ? 'var(--train-gen)' : 'var(--train-built)';
      return L.divIcon({
        className:'',
        html:`<div class="train-badge" style="background:${bg}">ðŸš†</div>`,
        iconSize:[28,22],
        iconAnchor:[14,11]
      });
    };

    const activeRoute = { pathNames: [], geom: [], nameToLL: new Map() };

    // Small helpers for feedback UI
    function showError(msg){ result.innerHTML = `<div class="error">${msg}</div>`; }
    function showOk({from,to,stops,time,price}){
      const timeStr = (time!=null) ? `${time}` : 'N/A';
      const fareStr = (price!=null) ? `RM ${Number(price).toFixed(2)}` : 'N/A';
      result.innerHTML = `<div class="ok">
          <div>From <b>${from}</b> to <b>${to}</b></div>
          <div style="margin-top:4px;">Via: <b>${stops}</b> stops</div>
          <div style="margin-top:4px;">Time: <b>${timeStr}</b> min, Fare: <b>${fareStr}</b></div>
          <div class="path" id="pathChips" style="margin-top:10px"></div>
        </div>`;
    }

    // Fetch station list and draw gray dots
    async function loadStations(){
      fromSel.innerHTML = '<option>Loadingâ€¦</option>';
      toSel.innerHTML   = '<option>Loadingâ€¦</option>';
      const res = await fetch('/stations');
      const js  = await res.json();
      const names = (js.data || []).map(s=>s.name);
      const opts = names.map(n=>`<option value="${n}">${n}</option>`).join('');
      fromSel.innerHTML = `<option value="">Select origin</option>` + opts;
      toSel.innerHTML   = `<option value="">Select destination</option>` + opts;

      // Pre-select a sensible demo route for quick testing
      const trySet = (sel, name)=>{ const opt = Array.from(sel.options).find(o=>o.value.toLowerCase()===name.toLowerCase()); if(opt) sel.value = opt.value; };
      trySet(fromSel, 'KLCC'); trySet(toSel, 'Kajang');

      // Cache coordinates and render station markers
      (js.data || []).forEach(s=>{
        const key = String(s.name).toLowerCase();
        if(s.latitude!=null && s.longitude!=null){
          stationCoords.set(key, {lat:s.latitude, lng:s.longitude});
          const color = '#6b7280';
          const m = L.circleMarker([s.latitude, s.longitude], {
            radius:4, weight:1, color:color, fillColor:color, fillOpacity:.95
          }).bindTooltip(s.name).addTo(map);
          stationMarkers.set(key, m);
        }
      });
    }

    // Swap origin and destination selections
    swapBtn.onclick = ()=>{ const a = fromSel.value; fromSel.value = toSel.value; toSel.value = a; };

    // Plan a route
    planBtn.onclick = async ()=>{
      const from = fromSel.value.trim();
      const to   = toSel.value.trim();
      if(!from || !to){ showError('Please select origin and destination'); return; }
      planBtn.disabled = true; planBtn.textContent = 'Planningâ€¦';

      try {
        const rUrl = `/route_by_name?from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}&mode=time`;
        const fUrl = `/fare_by_name?from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}`;
        const [rRes, fRes] = await Promise.all([fetch(rUrl), fetch(fUrl)]);
        const rJs = await rRes.json();
        const fJs = await fRes.json();
        if(!rRes.ok){ showError(`Route not found (${from} â†’ ${to})`); return; }

        const path = rJs.path_names || [];
        activeRoute.pathNames = path;

        showOk({
          from, to,
          stops: rJs.total_stops,
          time:  rJs.total_time,
          price: (fRes.ok ? fJs.price : null)
        });

        // Build small "chips" visual for the path
        const chips = [];
        for(let i=0;i<path.length;i++){
          const node = `<span class="chip">${path[i]}</span>`;
          chips.push(node);
          if(i<path.length-1) chips.push(`<span class="arrow">â†’</span>`);
        }
        $('#pathChips').innerHTML = chips.join(' ');

        // Convert route names to geometry
        buildRouteGeometry(path);

        // Draw purple polyline and fit bounds
        if(routeLine){ map.removeLayer(routeLine); routeLine = null; }
        if(activeRoute.geom.length >= 2){
          routeLine = L.polyline(activeRoute.geom, {color:'var(--route)', weight:5, opacity:.95}).addTo(map);
          map.fitBounds(routeLine.getBounds(), {padding:[30,30]});
        }

        // Reset progress UI
        totalBar.style.width = '0%';
        totalPct.textContent = '0%';

      } catch (e){
        console.error(e);
        showError('Request failed. Is the backend running?');
      } finally {
        planBtn.disabled = false; planBtn.textContent = 'Plan Route';
      }
    };

    // Build list of lat/lng for the current path
    function buildRouteGeometry(path){
      activeRoute.geom = [];
      activeRoute.nameToLL = new Map();

      // Try real coordinates for each station first
      const real = [];
      let allHave = true;
      for(const n of path){
        const c = stationCoords.get(n.toLowerCase());
        if(!c){ allHave = false; break; }
        real.push([c.lat, c.lng]);
        activeRoute.nameToLL.set(n.toLowerCase(), {lat:c.lat,lng:c.lng});
      }
      if(allHave && real.length>=2){ activeRoute.geom = real; return; }

      // Fallback which generate a straight-ish synthetic line if coords missing
      const A = L.latLng(3.20, 101.64);
      const B = L.latLng(3.00, 101.76);
      const N = Math.max(2, path.length);
      for(let i=0;i<N;i++){
        const t = (N===1)?0:(i/(N-1));
        const lat = A.lat + (B.lat - A.lat)*t;
        const lng = A.lng + (B.lng - A.lng)*t;
        const name = path[i];
        activeRoute.geom.push([lat,lng]);
        activeRoute.nameToLL.set(name.toLowerCase(), {lat,lng});
      }
    }

    // Built-in simulator controls
    simBtn.onclick = async ()=>{
      const from = fromSel.value.trim();
      const to   = toSel.value.trim();
      if(!from || !to){ showError('Please select origin and destination'); return; }
      simBtn.disabled = true; simBtn.textContent = 'Startingâ€¦';
      try{
        // Ask backend to start a train that moves along the planned path
        const resp = await fetch('/simulate_train', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ from, to, mode: 'time', speed: 6, loop: true, ping_interval: 1 })
        });
        const js = await resp.json();
        if(!resp.ok){ showError('Start failed: ' + (js.error || '')); }
      }catch(e){ showError('Request failed'); }
      finally{ simBtn.disabled = false; simBtn.textContent = 'Start Simulation'; }
    };

    // Stop all running trains (which built-in)
    stopBtn.onclick = async ()=>{
      try{
        const list = await fetch('/trains').then(r=>r.json());
        const ids = list.trains || [];
        await Promise.all(ids.map(id=>fetch('/trains/'+encodeURIComponent(id), {method:'DELETE'})));
      }catch(e){ showError('Stop failed'); }
    };

    // Realtime handling
    const ws = new WebSocket(`ws://${location.host}/ws`);
    ws.addEventListener('message', (ev)=>{
      try{
        const js = JSON.parse(ev.data);
        if(js.type === 'train_tick'){
          updateChipsOnProgress(js.origin, js.dest, js.progress);
          updateTotalProgress(js.origin, js.dest, js.progress);
          moveTrain(js.train_id, js.origin, js.dest, js.progress, 'built');
          return;
        }
        if(js.type === 'train_update'){
          updateChipsOnProgress(js.from, js.to, js.progress);
          updateTotalProgress(js.from, js.to, js.progress);
          moveTrain(js.train_id, js.from, js.to, js.progress, 'gen');
          return;
        }
      }catch(e){}
    });

    // Highlight current chip as the train enters a segment
    function updateChipsOnProgress(origin, dest, segProgress){
      const pathBox = document.getElementById('pathChips');
      if(!pathBox) return;
      const chips = [...pathBox.querySelectorAll('.chip')];
      chips.forEach(ch=>ch.classList.remove('active'));

      const o = String(origin).toLowerCase();
      const d = String(dest).toLowerCase();

      if(segProgress <= 0.05){
        const ch = chips.find(el=>el.textContent.trim().toLowerCase()===o);
        if(ch) ch.classList.add('active');
        return;
      }
      if(segProgress >= 0.95){
        const ch = chips.find(el=>el.textContent.trim().toLowerCase()===d);
        if(ch) ch.classList.add('active');
        return;
      }
    }

    // Update overall trip % based on segment index and intra-segment progress
    function updateTotalProgress(origin, dest, segProgress){
      const path = activeRoute.pathNames || [];
      if(path.length < 2) return;
      const i1 = path.findIndex(n=>n.toLowerCase()===String(origin).toLowerCase());
      const i2 = path.findIndex(n=>n.toLowerCase()===String(dest).toLowerCase());
      if(i1<0 || i2<0) return;
      const done = Math.min(i1, i2);
      const totalSeg = path.length - 1;
      let pct = ((done + Math.max(0,Math.min(1,segProgress))) / totalSeg) * 100;
      pct = Math.max(0, Math.min(100, pct));
      totalBar.style.width = pct.toFixed(1) + '%';
      totalPct.textContent = pct.toFixed(1) + '%';
    }

    // Move a train marker linearly between segment endpoints
    function moveTrain(trainId, origin, dest, segProgress, source){
      const a = activeRoute.nameToLL.get(String(origin).toLowerCase());
      const b = activeRoute.nameToLL.get(String(dest).toLowerCase());
      let lat,lng;
      if(a && b){
        lat = a.lat + (b.lat-a.lat) * Math.max(0,Math.min(1,segProgress));
        lng = a.lng + (b.lng-a.lng) * Math.max(0,Math.min(1,segProgress));
      }else{
        // Fallback: look up by global station coords if route geometry not built yet
        const aa = stationCoords.get(String(origin).toLowerCase());
        const bb = stationCoords.get(String(dest).toLowerCase());
        if(!aa || !bb) return;
        lat = aa.lat + (bb.lat-aa.lat) * Math.max(0,Math.min(1,segProgress));
        lng = aa.lng + (bb.lng-aa.lng) * Math.max(0,Math.min(1,segProgress));
      }
      placeTrain(trainId, lat, lng, source);
    }

    // Create/update a train marker; keeps a single marker per train_id
    function placeTrain(id, lat, lng, source){
      let t = trains.get(id);
      const ic = iconTrain(source);
      if(!t){
        t = {marker: L.marker([lat,lng], {icon: ic}).addTo(map), source};
        trains.set(id, t);
      }else{
        t.source = source;
        t.marker.setIcon(ic);
        t.marker.setLatLng([lat,lng]);
      }
    }

    // Initial data load on page start
    loadStations();
  </script>
</body>
</html>
